import csv
import random

class CustomHashTable:
    def __init__(self, size=100003):  # IniÈ›ializare hash table cu o dimensiune de 100003 (numÄƒr prim)
        self.size = size  # SeteazÄƒ dimensiunea tabelului hash
        self.table = [[] for _ in range(self.size)]  # CreeazÄƒ un tabel hash cu liste goale (coliziuni gestionate prin chaining)

    def custom_hash_function(self, cnp):
        """FuncÈ›ie de hash simplÄƒ bazatÄƒ pe metoda multiplicativÄƒ."""
        hash_value = 0  # IniÈ›ializarea valorii de hash
        prime = 31  # Folosim un numÄƒr prim pentru calculul hash-ului
        for char in cnp:  # IterÄƒm prin fiecare caracter din CNP
            hash_value = (hash_value * prime + ord(char)) % self.size  # CalculÄƒm valoarea hash
        return hash_value  # ReturneazÄƒ valoarea hash finalÄƒ

    def insert(self, cnp, nume):
        """InsereazÄƒ un CNP È™i numele asociat Ã®n tabelul hash."""
        index = self.custom_hash_function(cnp)  # CalculÄƒm indexul pentru CNP
        # VerificÄƒm dacÄƒ CNP-ul nu existÄƒ deja Ã®n lista de la indexul respectiv
        if not any(entry[0] == cnp for entry in self.table[index]):
            self.table[index].append((cnp, nume))  # AdÄƒugÄƒm perechea CNP-nume Ã®n bucket-ul corespunzÄƒtor
            print(f"ğŸ“Œ Inserat: {cnp} ({nume}) la index {index}")  # AfiÈ™Äƒm confirmarea inserÄƒrii

    def contains(self, cnp):
        """VerificÄƒ dacÄƒ un CNP existÄƒ È™i returneazÄƒ numÄƒrul de iteraÈ›ii."""
        index = self.custom_hash_function(cnp)  # CalculÄƒm indexul pentru CNP
        bucket = self.table[index]  # ObÈ›inem bucket-ul corespunzÄƒtor
        iterations = 0  # Contor pentru numÄƒrul de iteraÈ›ii (elemente verificate)
        for stored_cnp, nume in bucket:  # IterÄƒm prin fiecare element din bucket
            iterations += 1  # IncrementÄƒm numÄƒrul de iteraÈ›ii
            if stored_cnp == cnp:  # DacÄƒ CNP-ul cÄƒutat se aflÄƒ Ã®n bucket
                return True, iterations, nume  # ReturnÄƒm True, numÄƒrul de iteraÈ›ii È™i numele asociat
        return False, iterations, None  # DacÄƒ CNP-ul nu a fost gÄƒsit, returnÄƒm False È™i numÄƒrul de iteraÈ›ii

def incarca_si_insereaza_cnp(uri, hash_table):
    """ÃncarcÄƒ CNP-urile din fiÈ™ier È™i le insereazÄƒ Ã®n hash table."""
    with open(uri, mode='r', newline='') as file:
        reader = csv.reader(file)  # Citim fiÈ™ierul CSV
        next(reader)  # Sari peste antetul fiÈ™ierului
        for row in reader:  # Pentru fiecare rÃ¢nd (CNP È™i nume)
            cnp, nume = row  # DespÄƒrÈ›im CNP-ul È™i numele
            hash_table.insert(cnp, nume)  # InserÄƒm CNP-ul È™i numele Ã®n tabelul hash

def interfata_cautare(hash_table):
    """InterfaÈ›Äƒ pentru cÄƒutarea unui CNP specific."""
    while True:
        cnp = input("ğŸ” IntroduceÈ›i CNP-ul pentru cÄƒutare (sau 'exit' pentru a ieÈ™i): ").strip()  # Citim CNP-ul de la utilizator
        if cnp.lower() == "exit":  # DacÄƒ utilizatorul scrie 'exit', ieÈ™im din buclÄƒ
            break
        found, iterations, nume = hash_table.contains(cnp)  # VerificÄƒm dacÄƒ CNP-ul existÄƒ Ã®n tabel
        if found:
            print(f"âœ… CNP {cnp} aparÈ›ine lui {nume}. GÄƒsit dupÄƒ {iterations} iteraÈ›ii.")
        else:
            print(f"âŒ CNP {cnp} NU a fost gÄƒsit. IteraÈ›ii: {iterations}")

def testeaza_cautare(hash_table, cnp_list):
    """CautÄƒ 1.000 de CNP-uri aleatorii È™i Ã®nregistreazÄƒ numÄƒrul de iteraÈ›ii."""
    sample_cnp = random.sample(cnp_list, 1000)  # Alegem 1.000 de CNP-uri aleatorii din listÄƒ
    total_iterations = 0  # IniÈ›ializÄƒm variabila pentru totalul iteraÈ›iilor

    print("\nğŸ” Ãnceperea testului de cÄƒutare pentru 1.000 CNP-uri...\n")
    for cnp in sample_cnp:  # IterÄƒm prin fiecare CNP ales aleatoriu
        _, iterations, _ = hash_table.contains(cnp)  # VerificÄƒm dacÄƒ CNP-ul existÄƒ
        total_iterations += iterations  # AdunÄƒm iteraÈ›iile

    avg_iterations = total_iterations / 1000  # CalculÄƒm media iteraÈ›iilor
    print(f"\nâœ… Test finalizat. NumÄƒr total de iteraÈ›ii: {total_iterations}")
    print(f"ğŸ“Š NumÄƒr mediu de iteraÈ›ii per cÄƒutare: {avg_iterations:.2f}")

# Generare CNP-uri È™i nume pentru testare
prenume = ['Andrei', 'Maria', 'Ion', 'Elena', 'Vasile']
nume_familie = ['Popescu', 'Ionescu', 'Georgescu', 'Stan', 'Dumitrescu']
cnp_date = []

for _ in range(1000000):  # GenerÄƒm 1 milion de CNP-uri
    cnp = str(random.randint(1000000000000, 2999999999999))  # CNP aleatoriu (12 caractere)
    nume_complet = f"{random.choice(prenume)} {random.choice(nume_familie)}"  # Nume aleatoriu
    cnp_date.append((cnp, nume_complet))  # AdÄƒugÄƒm perechea CNP-nume Ã®n listÄƒ

# SalvÄƒm datele Ã®ntr-un fiÈ™ier CSV
with open("cnp_date.csv", mode='w', newline='') as file:
    writer = csv.writer(file)  # CreÄƒm un writer pentru fiÈ™ierul CSV
    writer.writerow(['CNP', 'Nume complet'])  # Scriem antetul
    writer.writerows(cnp_date)  # Scriem datele CNP

# IniÈ›ializare hash table È™i inserare CNP-uri
hash_table = CustomHashTable()  # CreÄƒm o instanÈ›Äƒ a tabelului hash
incarca_si_insereaza_cnp("cnp_date.csv", hash_table)  # ÃncÄƒrcÄƒm È™i inserÄƒm CNP-urile din fiÈ™ier

# Testare cÄƒutare pentru 1.000 de CNP-uri
testeaza_cautare(hash_table, [cnp for cnp, _ in cnp_date])  # TestÄƒm cÄƒutÄƒrile pentru 1.000 de CNP-uri

# Pornire interfaÈ›Äƒ pentru cÄƒutare manualÄƒ
interfata_cautare(hash_table)  # Permitem utilizatorului sÄƒ caute CNP-uri manual
